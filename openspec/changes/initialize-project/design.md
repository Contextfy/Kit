## 背景

Contextfy/Kit 项目目前为空 - 只有文档存在（PRD、架构、MVP）。在实现复杂功能之前，我们需要建立基础。本设计专注于创建所有主要组件的最小、可工作的实现，能够展示核心价值主张：解析文档、高效存储以及通过多个接口检索。

**关键约束：**
- 实现应该是最小化的（helloworld 级别）
- 专注于组件之间的连通性而非功能完整性
- 在优化之前验证架构模式
- 所有部分必须端到端地连接在一起

## 目标 / 非目标

**目标：**
- 建立一个包含多个 crate 的可工作的 Rust 工作空间
- 创建一个简单但功能正常的 markdown 解析器
- 设置具有基本 schema 的 LanceDB 存储
- 实现能够解析、索引和搜索文档的 CLI
- 创建具有基本搜索功能的 web 仪表盘
- 为 Node.js 集成提供 FFI 存根（供未来使用）
- 展示从初始化到搜索的完整用户流程

**非目标：**
- 生产级性能优化
- 复杂的嵌入生成（目前使用简单文本匹配）
- 完整的 BM25/向量搜索实现
- 完整的 Python 绑定
- 生产就绪的错误处理
- 全面的测试覆盖（仅基本验证）

## 决策

### 1. 使用 Cargo 工作空间的 Monorepo 结构
**决策**：使用 Cargo 工作空间在 monorepo 中管理多个 Rust 包。

**理由**：
- 共享依赖减少重复
- 易于测试包之间的集成
- 简化构建过程
- 与 `docs/Architecture.md` 中记录的架构一致

**结构**：
```
packages/
├── core/      # 库：解析器、存储、检索器
├── bridge/    # Node.js/Python 的 FFI 绑定
├── server/    # Web 服务器（Axum + Tokio）
└── cli/       # 命令行接口
```

### 2. 简化的 Markdown 解析器
**决策**：使用 `pulldown-cmark` 进行基本 AST 解析，没有复杂的切片逻辑。

**理由**：
- MVP 要求："helloworld" 实现
- 完整的语义切片可以稍后添加
- 首先专注于文件 I/O 和基本提取
- 可以使用简单的标题/内容提取验证文档结构

**Schema**：
```rust
struct ParsedDoc {
    path: String,
    title: String,      // 第一个 H1 标题
    summary: String,    // 前 200 个字符
    content: String,    // 完整的 markdown 内容
}
```

### 3. 具有最小 Schema 的 LanceDB
**决策**：使用 LanceDB 进行存储，采用单表设计，最初没有复杂的索引。

**理由**：
- LanceDB 是文档化的存储引擎
- Schema 可以随着功能的添加而演进
- 从简单的扁平表开始以简化实现
- 向量嵌入可以在第 2 阶段添加

**Schema**：
```rust
struct KnowledgeRecord {
    id: String,         // UUID
    title: String,
    summary: String,
    content: String,
}
```

### 4. 基于文本的搜索（暂无向量/BM25）
**决策**：最初实现简单的文本匹配进行搜索，推迟向量嵌入。

**理由**：
- 验证存储和检索流程
- 允许专注于 CLI 和 UI 集成
- FastEmbed 和 BM25 可以在后续阶段添加
- 文本搜索足以用于 "helloworld" 验证

**算法**：在 `title` 和 `summary` 字段中进行简单的子字符串匹配。

### 5. 使用 Next.js + Axum 的 Web 仪表盘
**决策**：前端使用 Next.js，后端使用 Axum，通过 REST API 通信。

**理由**：
- Next.js 提供现代 React 体验
- Axum 快速且异步（匹配 Rust 技术栈）
- REST API 简单且易于理解
- 如果需要，可以稍后演变为 WebSocket

**架构**：
```
前端 (Next.js) --HTTP--> 后端 (Axum) --调用--> 核心 (Rust 库)
```

### 6. 存根 FFI 绑定
**决策**：创建具有模拟实现的最小 napi-rs 结构。

**理由**：
- 验证构建系统可以生成 Node.js 绑定
- 一旦核心稳定，可以填充实际的 FFI 逻辑
- 防止在 FFI 复杂性上阻塞
- 符合 "helloworld" 要求

## 风险 / 权衡

### 风险 1：过度简化限制未来增长
**风险**：开始太简单可能以后需要大量重构。

**缓解措施**：
- 清楚地记录假设和限制
- 设计接口以允许扩展（基于 trait）
- 第 2 阶段可以增量添加高级功能
- 从一开始就遵循文档化的架构模式

### 风险 2：复杂性爆炸
**风险**：即使多个组件的 "helloworld" 实现也可能变得复杂。

**缓解措施**：
- 在 `tasks.md` 中进行严格的任务分解
- 按顺序而非并行实现组件
- 在移至下一个之前验证每个组件
- 保持每个文件 < 200 行

### 权衡：文本搜索 vs 向量搜索
**选择**：从文本搜索开始，推迟向量。

**影响**：
- 优点：实现更简单，交付更快
- 缺点：搜索质量较低，无法验证核心差异点

**缓解措施**：将此记录为临时的，在第 2 阶段添加向量。

## 迁移计划

由于这是初始实现，无需迁移。未来的变更将遵循以下阶段：

**第 1 阶段（此变更）**：基础连通性
- 文件 I/O、存储、搜索、CLI、web UI

**第 2 阶段**：增强能力
- 使用 FastEmbed 的向量嵌入
- BM25 关键词搜索
- 真实的 FFI 实现
- 增量构建

**第 3 阶段**：生产优化
- 错误处理
- 日志和可观测性
- 性能优化
- 全面测试

## 开放问题

1. **问题**：我们应该在此变更中包含示例 Context Pack 吗？
   **答案**：不，使用 `docs/examples/` 中的简单 markdown 文件进行验证。Context Pack 格式可以在第 2 阶段定义。

2. **问题**：CLI 应该是单独的 crate 还是 `server` 的一部分？
   **答案**：单独的 crate（`packages/cli`）提供清晰的关注点分离，并允许 CLI 独立于 web 服务器演进。

3. **问题**：web UI 应该如何与后端认证？
   **答案**：helloworld 不需要认证。仅限 localhost 的本地访问就足够了。

## 实现顺序

1. **设置**：Cargo 工作空间、基本 crate 结构
2. **核心**：解析器 → 存储 → 检索器（按顺序，每个都验证）
3. **CLI**：使用核心的命令
4. **服务器**：基本 HTTP 端点
5. **Web UI**：调用服务器的 Next.js 页面
6. **桥接**：存根 FFI 绑定
7. **集成**：端到端验证

## 成功标准

当以下情况时，实现是成功的：
1. 用户可以运行 `contextfy init` 并获得项目结构
2. 用户可以运行 `contextfy build` 并看到文件被索引
3. 用户可以运行 `contextfy scout "keyword"` 并获得结果
4. 用户可以启动 web 服务器并通过 UI 搜索
5. 所有组件编译无错误
6. 简单的端到端流程从命令行到 web UI 都能工作
